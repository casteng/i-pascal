{
  generateTokens=true
  generatePsi=true

  parserClass="com.siberika.idea.pascal.lang.parser.PascalParser"
  parserUtilClass="com.siberika.idea.pascal.lang.parser.PascalParserUtil"

  implements="com.siberika.idea.pascal.lang.psi.PascalPsiElement"
  extends="com.siberika.idea.pascal.lang.psi.impl.PascalPsiElementImpl"

  psiClassPrefix="Pas"
  psiImplClassSuffix="Impl"
  psiPackage="com.siberika.idea.pascal.lang.psi"
  psiImplPackage="com.siberika.idea.pascal.lang.psi.impl"
  psiImplUtilClass="com.siberika.idea.pascal.lang.psi.impl.PascalPsiImplUtil"

  elementTypeHolderClass="com.siberika.idea.pascal.lang.psi.PasTypes"
  elementTypePrefix=""
  elementTypeClass="com.siberika.idea.pascal.lang.psi.PascalPsiElementType"
  tokenTypeClass="com.siberika.idea.pascal.lang.lexer.PascalElementType"

  consumeTokenMethod(".*_Expr|Expr")="consumeTokenFast"

  tokens = [
        STRING_LITERAL="STRING_LITERAL"

        AND="regexp:(?i)and"
        AND_="regexp:(?i)&and"
        MOD="regexp:(?i)mod"
        MOD_="regexp:(?i)&mod"
        OR="regexp:(?i)or"
        OR_="regexp:(?i)&or"
        IDIV="regexp:(?i)div"
        IDIV_="regexp:(?i)&div"
        SHR="regexp:(?i)shr"
        SHR_="regexp:(?i)&shr"
        SHL="regexp:(?i)shl | <<"
        SHL_="regexp:(?i)&shl"
        IN="regexp:(?i)in"
        IN_="regexp:(?i)&in"

        AS="regexp:(?i)as"
        AS_="regexp:(?i)&as"
        IS="regexp:(?i)is"
        IS_="regexp:(?i)&is"
        NIL="regexp:(?i)nil"
        NIL_="regexp:(?i)&nil"

        CLASS="regexp:(?i)class"
        CLASS_="regexp:(?i)&class"
        OBJC_CLASS="regexp:(?i)objcclass"
        DISPINTERFACE="regexp:(?i)dispinterface"
        DISPINTERFACE_="regexp:(?i)&dispinterface"
        OBJC_PROTOCOL="objcprotocol"
        OBJC_CATEGORY="objccategory"

        TRY="regexp:(?i)try"
        TRY_="regexp:(?i)&try"
        RAISE="regexp:(?i)raise"
        RAISE_="regexp:(?i)&raise"
        EXCEPT="regexp:(?i)except"
        EXCEPT_="regexp:(?i)&except"
        ON="regexp:(?i)on"
        ON_="regexp:(?i)&on"
        FINALLY="regexp:(?i)finally"
        FINALLY_="regexp:(?i)&finally"

        PROGRAM="regexp:(?i)program"
        PROGRAM_="regexp:(?i)&program"
        UNIT="regexp:(?i)unit"
        UNIT_="regexp:(?i)&unit"
        LIBRARY="regexp:(?i)library"
        LIBRARY_="regexp:(?i)&library"
        PACKAGE="regexp:(?i)package"
        PACKAGE_="regexp:(?i)&package"
        USES="regexp:(?i)uses"
        USES_="regexp:(?i)&uses"
        EXPORTS="regexp:(?i)exports"
        EXPORTS_="regexp:(?i)&exports"
        FINALIZATION="regexp:(?i)finalization"
        FINALIZATION_="regexp:(?i)&finalization"
        INITIALIZATION="regexp:(?i)initialization"
        INITIALIZATION_="regexp:(?i)&initialization"

        THREADVAR="regexp:(?i)threadvar"
        THREADVAR_="regexp:(?i)&threadvar"
        ABSOLUTE="regexp:(?i)absolute"
        ABSOLUTE_="regexp:(?i)&absolute"
        OUT="regexp:(?i)out"
        OUT_="regexp:(?i)&out"
        CONSTREF="regexp:(?i)constref"
        CONSTREF_="regexp:(?i)&constref"
        RESOURCESTRING="regexp:(?i)resourcestring"
        RESOURCESTRING_="regexp:(?i)&resourcestring"
        INLINE="regexp:(?i)inline"
        INLINE_="regexp:(?i)&inline"
        PACKED="regexp:(?i)packed"
        PACKED_="regexp:(?i)&packed"
        PROPERTY="regexp:(?i)property"
        PROPERTY_="regexp:(?i)&property"
        SET="regexp:(?i)set"
        SET_="regexp:(?i)&set"
        FILE="regexp:(?i)file"
        FILE_="regexp:(?i)&file"

        ASM="regexp:(?i)asm"
        ASM_="regexp:(?i)&asm"
        GOTO="regexp:(?i)goto"
        GOTO_="regexp:(?i)&goto"
        LABEL="regexp:(?i)label"
        LABEL_="regexp:(?i)&label"
        WITH="regexp:(?i)with"
        WITH_="regexp:(?i)&with"
        EXIT="regexp:(?i)exit"
        EXIT_="regexp:(?i)&exit"
        CONTINUE="regexp:(?i)continue"
        CONTINUE_="regexp:(?i)&continue"
        BREAK="regexp:(?i)break"
        BREAK_="regexp:(?i)&break"

        CONSTRUCTOR="regexp:(?i)constructor"
        CONSTRUCTOR_="regexp:(?i)&constructor"
        DESTRUCTOR="regexp:(?i)destructor"
        DESTRUCTOR_="regexp:(?i)&destructor"
        INHERITED="regexp:(?i)inherited"
        INHERITED_="regexp:(?i)&inherited"
        OBJECT="regexp:(?i)object"
        OBJECT_="regexp:(?i)&object"
        OPERATOR="regexp:(?i)operator"
        OPERATOR_="regexp:(?i)&operator"
        REINTRODUCE="regexp:(?i)reintroduce"
        REINTRODUCE_="regexp:(?i)&reintroduce"
        SELF="regexp:(?i)self"
        SELF_="regexp:(?i)&self"
        GENERIC="regexp:(?i)generic"
        SPECIALIZE="regexp:(?i)specialize"

        NOT="regexp:(?i)not"
        NOT_="regexp:(?i)&not"
        XOR="regexp:(?i)xor"
        XOR_="regexp:(?i)&xor"

        TO="regexp:(?i)to"
        TO_="regexp:(?i)&to"
        DOWNTO="regexp:(?i)downto"
        DOWNTO_="regexp:(?i)&downto"
        REPEAT="regexp:(?i)repeat"
        REPEAT_="regexp:(?i)&repeat"

        STATIC="regexp:(?i)static"
        STATIC_="regexp:(?i)&static"
        SEALED="regexp:(?i)sealed"
        SEALED_="regexp:(?i)&sealed"
        FINAL="regexp:(?i)final"
        FINAL_="regexp:(?i)&final"
        HELPER="regexp:(?i)helper"
        HELPER_="regexp:(?i)&helper"
        EXPORT="regexp:(?i)export"
        EXPORT_="regexp:(?i)&export"
        DISPID="regexp:(?i)dispid"
        DISPID_="regexp:(?i)&dispid"
        ABSTRACT="regexp:(?i)abstract"
        ABSTRACT_="regexp:(?i)&abstract"

        STRICT="regexp:(?i)strict"
        STRICT_="regexp:(?i)&strict"
        PUBLISHED="regexp:(?i)published"
        PUBLISHED_="regexp:(?i)&published"
        PUBLIC="regexp:(?i)public"
        PUBLIC_="regexp:(?i)&public"
        PROTECTED="regexp:(?i)protected"
        PROTECTED_="regexp:(?i)&protected"
        PRIVATE="regexp:(?i)private"
        PRIVATE_="regexp:(?i)&private"
        AUTOMATED="regexp:(?i)automated"
        AUTOMATED_="regexp:(?i)&automated"

        MESSAGE="regexp:(?i)message"
        MESSAGE_="regexp:(?i)&message"
        FORWARD="regexp:(?i)forward"
        FORWARD_="regexp:(?i)&forward"
        EXTERNAL="regexp:(?i)external"
        EXTERNAL_="regexp:(?i)&external"
        EXPERIMENTAL="regexp:(?i)experimental"
        EXPERIMENTAL_="regexp:(?i)&experimental"
        DEPRECATED="regexp:(?i)deprecated"
        DEPRECATED_="regexp:(?i)&deprecated"
        ASSEMBLER="regexp:(?i)assembler"
        ASSEMBLER_="regexp:(?i)&assembler"

        INDEX="regexp:(?i)index"
        INDEX_="regexp:(?i)&index"
        DEFAULT="regexp:(?i)default"
        DEFAULT_="regexp:(?i)&default"

        VIRTUAL="regexp:(?i)virtual"
        VIRTUAL_="regexp:(?i)&virtual"
        DYNAMIC="regexp:(?i)dynamic"
        DYNAMIC_="regexp:(?i)&dynamic"
        OVERRIDE="regexp:(?i)override"
        OVERRIDE_="regexp:(?i)&override"
        OVERLOAD="regexp:(?i)overload"
        OVERLOAD_="regexp:(?i)&overload"

        REGISTER="regexp:(?i)register"
        REGISTER_="regexp:(?i)&register"
        STDCALL="regexp:(?i)stdcall"
        STDCALL_="regexp:(?i)&stdcall"
        PLATFORM="regexp:(?i)platform"
        PLATFORM_="regexp:(?i)&platform"
        PASCAL="regexp:(?i)pascal"
        PASCAL_="regexp:(?i)&pascal"
        CDECL="regexp:(?i)cdecl"
        CDECL_="regexp:(?i)&cdecl"
        SAFECALL="regexp:(?i)safecall"
        SAFECALL_="regexp:(?i)&safecall"

        REFERENCE="regexp:(?i)reference"
        REFERENCE_="regexp:(?i)&reference"

        IMPLEMENTS="regexp:(?i)implements"
        IMPLEMENTS_="regexp:(?i)&implements"
        REQUIRES="regexp:(?i)requires"
        REQUIRES_="regexp:(?i)&requires"
        CONTAINS="regexp:(?i)contains"
        CONTAINS_="regexp:(?i)&contains"

        FALSE="regexp:(?i)false"
        FALSE_="regexp:(?i)&false"
        TRUE="regexp:(?i)true"
        TRUE_="regexp:(?i)&true"

        INTERFACE="regexp:(?i)interface"
        INTERFACE_="regexp:(?i)&interface"
        IMPLEMENTATION="regexp:(?i)implementation"
        IMPLEMENTATION_="regexp:(?i)&implementation"

        VAR="regexp:(?i)var"
        VAR_="regexp:(?i)&var"
        CONST="regexp:(?i)const"
        CONST_="regexp:(?i)&const"
        TYPE="regexp:(?i)type"
        TYPE_="regexp:(?i)&type"
        ARRAY="regexp:(?i)array"
        ARRAY_="regexp:(?i)&array"
        RECORD="regexp:(?i)record"
        RECORD_="regexp:(?i)&record"
        PROCEDURE="regexp:(?i)procedure"
        PROCEDURE_="regexp:(?i)&procedure"
        FUNCTION="regexp:(?i)function"
        FUNCTION_="regexp:(?i)&function"
        OF="regexp:(?i)of"
        OF_="regexp:(?i)&of"

        CASE="regexp:(?i)case"
        CASE_="regexp:(?i)&case"
        BEGIN="regexp:(?i)begin"
        BEGIN_="regexp:(?i)&begin"
        END="regexp:(?i)end"
        END_="regexp:(?i)&end"
        FOR="regexp:(?i)for"
        FOR_="regexp:(?i)&for"
        UNTIL="regexp:(?i)until"
        UNTIL_="regexp:(?i)&until"
        WHILE="regexp:(?i)while"
        WHILE_="regexp:(?i)&while"
        DO="regexp:(?i)do"
        DO_="regexp:(?i)&do"
        IF="regexp:(?i)if"
        IF_="regexp:(?i)&if"
        THEN="regexp:(?i)then"
        THEN_="regexp:(?i)&then"
        ELSE="regexp:(?i)else"
        ELSE_="regexp:(?i)&else"

        READ="regexp:(?i)read"
        READ_="regexp:(?i)&read"
        WRITE="regexp:(?i)write"
        WRITE_="regexp:(?i)&write"

        POWER="**"
        MULT="*"
        PLUS="+"
        MINUS="-"
        DIV="/"
        SEMI=";"
        COMMA=","
        LPAREN="("
        RPAREN=")"
        LBRACK="["
        RBRACK="]"
        LTEQ="<="
        EQ="="
        LT="<"
        GT=">"
        NE="<>"
        COLON=":"
        ASSIGN=":="
        PLUS_ASSIGN="+="
        MINUS_ASSIGN="-="
        MULT_ASSIGN="*="
        DIV_ASSIGN="/="
        DOT="."
        DEREF="^"
        AT="@"
        HEXNUM="$"
        CHARNUM="#"

        INCLUDE="include"
        CT_DEFINE="ct_define"
        CT_UNDEFINE="ct_undefine"
        CT_IF="ct_if"
        CT_IFDEF="ct_ifdef"
        CT_IFNDEF="ct_ifndef"
        CT_IFOPT="ct_ifopt"
        CT_ELSE="ct_else"
        CT_ENDIF="ct_endif"
        COMP_OPTION="comp_option"

        COMMENT='regexp:\{[^}]*\}'
        COMMENT='regexp://.*'
        COMMENT='regexp:\(\*(.*\n)*.*\*\)'
        NAME='regexp:[_A-Za-z]\w*'
        NAME_='regexp:&+[_A-Za-z]\w*'
        RANGE='..'
        STRING_LITERAL="regexp:'[^'\n\r]*'"
        STRING_LITERAL_UNC="regexp:'[^'\n\r]*'?"
        NUMBER_INT='regexp:\d+'
        NUMBER_REAL='regexp:\d+(\.\d+)?([eE][+-]?\d+)?'
        NUMBER_HEX='regexp:\$[0-9abcdefABCDEF]+'
        NUMBER_OCT='regexp:\&[0-7]+'
        NUMBER_BIN='regexp:\%[01]+'
        WHITESPACE='regexp:[\ \n\r\t\f]'
  ]

  implements(".+Statement")="com.siberika.idea.pascal.lang.psi.PasStatement"
  implements(".*QualifiedIdent|NamespaceIdent|inOperatorName")="com.siberika.idea.pascal.lang.psi.PascalQualifiedIdent"
  implements(".*ModuleHead|.*Ident|ConstDeclaration")="com.siberika.idea.pascal.lang.psi.PascalNamedElement"
  implements("ConstSection|TypeSection|VarSection|ExportedRoutine|ClassMethodResolution|LabelDeclSection|ExportsSection|CustomAttributeDecl|ClosureRoutine")="com.siberika.idea.pascal.lang.psi.PasDeclSection"
  implements("RoutineImplDecl|ClosureRoutine|ExportedRoutine")="com.siberika.idea.pascal.lang.psi.PascalRoutine"
  extends(".+Statement")="com.siberika.idea.pascal.lang.psi.impl.PasStatementImpl"
  extends(".*ModuleHead|.*Ident|ConstDeclaration")="com.siberika.idea.pascal.lang.psi.impl.PascalNamedElementImpl"
  extends("RoutineImplDecl|ClosureRoutine")="com.siberika.idea.pascal.lang.psi.impl.PascalRoutineImpl"
  extends("ExportedRoutine")="com.siberika.idea.pascal.lang.psi.impl.PascalExportedRoutineImpl"
  extends(".*Expr")=Expr
  extends(".*Expression.*")="com.siberika.idea.pascal.lang.psi.impl.PascalExpression"
  implements(".*Op")="com.siberika.idea.pascal.lang.psi.PascalOperation"
  implements("VarDeclaration|FormalParameter|ClassField|InlineVarDeclaration|ForInlineDeclaration")="com.siberika.idea.pascal.lang.psi.PascalVariableDeclaration"
  implements("InlineVarDeclaration|InlineConstDeclaration|ForInlineDeclaration")="com.siberika.idea.pascal.lang.psi.PascalInlineDeclaration"
  name(".*Ident")="Identifier"
}

//external pascal             ::= parsePascal Module
Module                      ::= [prolog] (moduleUnit | moduleLibrary | modulePackage | moduleProgram | include_impl | include_intf)
                            {extends="com.siberika.idea.pascal.lang.psi.impl.PascalModuleImpl"
                             implements="com.siberika.idea.pascal.lang.psi.PascalModule"
                             stubClass="com.siberika.idea.pascal.lang.stub.PasModuleStub"
                             elementTypeClass="com.siberika.idea.pascal.lang.stub.PasModuleStubElementType"}

private include_impl        ::= [intUsesClause] declSection+ [unitBlock] {recoverWhile=rec_module_start}
private include_intf        ::= [intUsesClause] interfaceDecl+ {recoverWhile=rec_module_start}

private moduleProgram       ::= progWithHead | progWoHead
private progWithHead        ::= ProgramModuleHead progWoHead {pin=1}
private progWoHead          ::= [intUsesClause] BlockGlobal "." {pin=2 recoverWhile=rec_section_global}

private moduleUnit          ::= UnitModuleHead UnitInterface UnitImplementation "." {pin=1}
private prolog              ::= {recoverWhile=rec_module_start}
UnitModuleHead              ::= UNIT NamespaceIdent hintingDirective* ";" {pin=1 recoverWhile=rec_module}
private intUsesClause       ::= UsesClause
UsesClause                  ::= USES namespaceNameList ";" {pin=1 recoverWhile=rec_uses}

private moduleLibrary       ::= LibraryModuleHead [intUsesClause] libBlockGlobal "." {pin=1}
private libBlockGlobal      ::= ImplDeclSection END | BlockGlobal
LibraryModuleHead           ::= LIBRARY NamespaceIdent hintingDirective* ";" {pin=1}

private modulePackage       ::= PackageModuleHead RequiresClause [ContainsClause] END "." {pin=1}
PackageModuleHead           ::= PACKAGE NamespaceIdent ";" {pin=1}
RequiresClause              ::= REQUIRES namespaceNameList ";" {pin=1}
ContainsClause              ::= CONTAINS namespaceNameList ";" {pin=1}

UnitInterface               ::= unitInterfaceKey [intUsesClause] interfaceDecl* {pin=1 recoverWhile=rec_interface name="interface section"}
private unitInterfaceKey    ::= INTERFACE {recoverWhile=rec_sectionKey}

private rec_sectionKey      ::= !(USES) & rec_section
private rec_programHead     ::= !(USES) & rec_section
private rec_block_global_end ::= !(".")
private rec_block_local_end  ::= !(END | ";") & rec_section
private rec_decl_section    ::= !(END) & rec_section
private rec_uses            ::= !(END) & rec_section
private rec_module_start    ::= !(UNIT | LIBRARY | PROGRAM | PACKAGE | USES | END) & rec_section
private rec_module          ::= !(INTERFACE) & rec_interface
private rec_interface       ::= !(IMPLEMENTATION) & rec_implementation
private rec_implementation  ::= !(INITIALIZATION | FINALIZATION | BEGIN | ASM)
private rec_implementation_dot  ::= !(".") & rec_implementation
private rec_section_nested  ::= !(CLASS | TYPE | EXPORTS | varKey | constKey | PROPERTY | Visibility | LABEL | CASE |
                                 (identifier "<") | (END DOT) | "[") & rec_interface
private rec_section         ::= !rec__routine_key & rec_section_nested
private rec_section_global  ::= !(".") & rec_section
private rec_routine         ::= !(EXTERNAL | FORWARD) & rec_name & rec_interface
private rec_routine_decl    ::= !(EXTERNAL | FORWARD | CASE | ";") & rec_name & rec_interface
private rec_semi_section    ::= !(";" | "=" | "," | ">") & rec_section
private rec_semi            ::= !(";" | "deprecated" | "platform") & rec_section
private rec_struct_field    ::= !(";" | ")" | END | CASE | identifier ) & rec_section
private rec_struct_outer    ::= !(END | ";" | "(")
private rec__routine_key    ::= GENERIC PROCEDURE | GENERIC FUNCTION | PROCEDURE | FUNCTION | CONSTRUCTOR | DESTRUCTOR | OPERATOR
private rec_name            ::= !(GENERIC | identifier | END) & rec_section
private rec_case            ::= !(ELSE | END) & rec_section
private rec_caseItem        ::= !(END | ELSE | caseLabel)
private rec_classparent     ::= !(CASE | FOR | ";") & rec_name
private rec_typeId          ::= !("=" | "." | ";" | DO)
private rec_formal_param_sec::= !(";" | ":" | ">" | "]" | "," | OF | identifier) & rec_section
private rec_formal_param    ::= !(";" | ")" | "]") & rec_section
private rec_propspec        ::= !(READ | WRITE | "add" | "remove" | classPropertyDispInterface | "stored" | SEMI | DEFAULT | IMPLEMENTS)
private rec_generic_def     ::= !(">" | "," | ":" | ";" | ">""=") & rec_section

private rec_statements      ::= !(END | INITIALIZATION | FINALIZATION)
private rec_statement       ::= !(SEMI | ELSE | FINALLY | EXCEPT | UNTIL) & rec_statements
private rec_statement_mid   ::= !(DO | ELSE | THEN | TO | DOWNTO | OF | ON | SEMI | REPEAT | WHILE | FOR | CASE | WITH | RAISE | IF | TRY | FINALLY | EXCEPT | UNTIL | END) & rec_section
private rec_doKey           ::= !(identifier) & rec_statement_mid


private interfaceDecl       ::= commonDecl | routineDecl | ExportsSection | assemblyAttribute {recoverWhile=rec_block_local_end}
private assemblyAttribute   ::= "[" "assembly" ":" CustomAttributeDecl "]" {pin=1}
ExportsSection              ::= EXPORTS RefNamedIdent exportItem ("," RefNamedIdent exportItem)* ";" {pin=1}
private exportItem          ::= [FormalParameterSection] [INDEX Expression] ["name" Expression] ["resident"]

private operatorRedef       ::= ASSIGN | PLUS | MINUS | MULT | DIV | POWER | EQ | LTEQ | LT | GT | "<>" | IN | "explicit"
private procName            ::= ClassQualifiedIdent | NamedIdent {recoverWhile=rec_procName}
private operName            ::= procName ["." operatorRedef]
private rec_procName        ::= !("(" | "<" | ":" | ";" | ".") & rec_section
private methodKey           ::= PROCEDURE | CONSTRUCTOR | DESTRUCTOR
private procKey             ::= FUNCTION | PROCEDURE
private operatorName        ::= InOperatorQualifiedIdent | operName
InOperatorQualifiedIdent    ::= (SubIdent [GenericPostfix] ".")* OperatorSubIdent {extends=ClassQualifiedIdent}
OperatorSubIdent            ::= IN | operatorRedef {extends=SubIdent}

ExportedRoutine             ::= routineDeclaration [ExternalDirective] {implements="com.siberika.idea.pascal.lang.psi.PascalExportedRoutine"
                             stubClass="com.siberika.idea.pascal.lang.stub.PasExportedRoutineStub"
                             elementTypeClass="com.siberika.idea.pascal.lang.stub.PasExportedRoutineStubElementType"}

private routineDeclaration  ::= customAttributes* (exportedProc | exportedFunc | operatorDecl | classOperatorDecl) ";" FunctionDirective* {pin=2 recoverWhile=rec_routine_decl}
private exportedFunc        ::= [GENERIC] [CLASS] FUNCTION procName [genericDefinition] [FormalParameterSection] ":" customAttributes* TypeDecl {pin=3}
private exportedProc        ::= [GENERIC] [CLASS] methodKey procName [genericDefinition] [FormalParameterSection] {pin=3}
private operatorDecl        ::= OPERATOR operatorRedef FormalParameterSection [NamedIdent] ":" TypeDecl {pin=1}
private classOperatorDecl   ::= [CLASS] OPERATOR operatorName FormalParameterSection ":" TypeDecl {pin=2}

RoutineImplDecl             ::= routineImpl ProcBodyBlock {pin=1 name="procedure or function declaration"}
RoutineImplDeclNested1      ::= routineDeclaration (ProcForwardDecl | BlockLocalNested1) [";"] {extends=RoutineImplDecl}
RoutineImplDeclWoNested     ::= routineDeclaration (ProcForwardDecl | BlockLocalWONested) [";"] {extends=RoutineImplDecl}
private routineImpl         ::= customAttributes* (exportedProc | exportedFuncImpl | operatorDecl | classOperatorDecl) ";" FunctionDirective* {pin=2 recoverWhile=rec_routine}
private exportedFuncImpl    ::= [GENERIC] [CLASS] FUNCTION procName [genericDefinition] [FormalParameterSection] [":" customAttributes* TypeDecl] {pin=3}

ClassMethodResolution       ::= [CLASS] procKey GenericTypeIdent "." identifier "=" RefNamedIdent ";"

private complexType         ::= ClassTypeTypeDecl | structTypeDecl | ArrayType | SetType | FileType
private structTypeDecl      ::= ClassHelperDecl | ClassTypeDecl | InterfaceTypeDecl | ObjectDecl | RecordHelperDecl | RecordDecl

private routineDecl         ::= ClassMethodResolution | ExportedRoutine
private commonDecl          ::= [CLASS] VarSection | ClassProperty | ConstSection | TypeSection
private structItem          ::= commonDecl | routineDecl | classFieldSemi | Visibility {recoverWhile=rec_struct_field}
private declSection	        ::=	RoutineImplDecl | commonDecl | LabelDeclSection | ExportsSection | assemblyAttribute {recoverWhile=rec_decl_section}
private declSectionNested   ::= RoutineImplDeclNested1 | commonDecl | LabelDeclSection {recoverWhile=rec_decl_section}
private declSectionNested1  ::= RoutineImplDeclWoNested | commonDecl | LabelDeclSection {recoverWhile=rec_decl_section}
private declSectionWONested ::= commonDecl | LabelDeclSection {recoverWhile=rec_section_nested}

UnitImplementation          ::= unitImplementationKey [intUsesClause] ImplDeclSection unitBlock {pin=1 recoverWhile=rec_implementation_dot name="implementation section"}
private unitImplementationKey ::= IMPLEMENTATION {recoverWhile=rec_sectionKey}
ImplDeclSection             ::= declSection* {}
private unitBlock           ::= [UnitInitialization] [UnitFinalization] END | CompoundStatement | END {}
UnitInitialization          ::= INITIALIZATION statementList {pin=1 name="initialization section"}
UnitFinalization            ::= FINALIZATION statementList  {pin=1 name="finalization section"}

ProgramModuleHead	        ::= PROGRAM NamespaceIdent ProgramParamList? ";" {pin=1 recoverWhile=rec_programHead}
ProgramParamList            ::= LPAREN progParam? progParamsRest* RPAREN {pin=1}
private progParamsRest      ::= "," progParam {pin=1}
private progParam           ::= identifier {}

private namespaceNameList   ::= namespaceFileName namespaceNamesRest*
private namespaceNamesRest  ::= COMMA namespaceFileName {pin=1}
private namespaceFileName	::=	NamespaceIdent [IN quotedString] {recoverWhile=rec_semi_section}

BlockGlobal	                ::=	declSection* BlockBody {recoverWhile=rec_block_global_end}
BlockLocal 	                ::=	[';'] declSectionNested* BlockBody
BlockLocalNested1          ::=	[';'] declSectionNested1* BlockBody {pin=2}
BlockLocalWONested          ::=	[';'] declSectionWONested* BlockBody {pin=2}
BlockBody	                ::=	CompoundStatement |	AssemblerStatement

AssemblerStatement          ::= ASM asmBlock END {pin=1}
private asmBlock            ::= assemblerItem* {recoverWhile=rec_struct_outer}
private assemblerItem       ::= ',' | '[' | ']' | ':' | '+' | '-' | '*' | '/' | '@' | RefNamedIdent | NUMBER_INT | NUMBER_HEX | NUMBER_OCT | NUMBER_BIN | '.NOFRAME'

FunctionDirective           ::= functionDirective | dispIDDirective {pin=1 name="routine directive"}
private functionDirective   ::= (OVERLOAD | oldCallConventionDirective | INLINE | ASSEMBLER | callConvention | hintingDirective | REINTRODUCE | bindingDirective | abstractDirective) ";" {pin=1}

private oldCallConventionDirective ::= "far" | "local" | "near"
ExternalDirective           ::= EXTERNAL ";" | EXTERNAL externalSpecifier [libLoadSpec] ";" | EXTERNAL ConstExpression [externalSpecifier] [libLoadSpec] ";"
private varagrs             ::= "varargs"
private libLoadSpec         ::= "delayed" | "dependency" constExpr libListRest*
private libListRest         ::= COMMA constExpr
private externalSpecifier   ::= "name" ConstExpression | INDEX ConstExpressionOrd
ProcBodyBlock               ::= ProcForwardDecl | ExternalDirective | BlockLocal [";"]
ProcForwardDecl             ::= FORWARD ";" FunctionDirective*

private dispIDDirective     ::= DISPID Expression [";"] {pin=1}
private callConvention      ::= CDECL | PASCAL | REGISTER | SAFECALL | STDCALL | EXPORT | varagrs
private abstractDirective   ::= ABSTRACT | FINAL
private bindingDirective    ::= (MESSAGE Expression) | STATIC | DYNAMIC | OVERRIDE | VIRTUAL

LabelDeclSection	        ::=	LABEL label labelsRest* ";" {pin=1 name="label declaration"}
private labelsRest          ::= "," label {}
private label               ::= NamedIdent | NUMBER_INT | NUMBER_HEX

private identListDecl       ::= identListDeclItem identListDeclRest*
private identListDeclRest   ::= "," identListDeclItem {pin=1}
private identListDeclItem   ::= NamedIdentDecl

VarSection	                ::=	varKey varDeclarations [";"] {pin=1 name="var section" recoverWhile=rec_decl_section}
private varDeclarations     ::= VarDeclaration+ {recoverWhile=rec_block_local_end}
private varKey	            ::=	VAR | THREADVAR
VarDeclaration	            ::=	customAttributes* identListDecl ":" TypeDecl [VarValueSpec] hintingDirective* ";" {pin=2 recoverWhile=rec_name}
VarValueSpec	            ::=	ABSOLUTE FullyQualifiedIdent | ABSOLUTE ConstExpressionOrd | EQ ConstExpression {recoverWhile=rec_semi}

ConstSection                ::= constKey constDeclarations [";"] {pin=1 name="const section" recoverWhile=rec_decl_section}
private constDeclarations   ::= ConstDeclaration+ {recoverWhile=rec_block_local_end}
private constKey            ::= CONST |	RESOURCESTRING
ConstDeclaration            ::= customAttributes* NamedIdentDecl [":" TypeDecl] "=" ConstExpression hintingDirective* ";" {pin=2 recoverWhile=rec_name}
NamedIdentDecl              ::= identifier {extends="com.siberika.idea.pascal.lang.psi.impl.PascalIdentDeclImpl"
                                            implements="com.siberika.idea.pascal.lang.psi.PascalIdentDecl"
                                            stubClass="com.siberika.idea.pascal.lang.stub.PasIdentStub"
                                            elementTypeClass="com.siberika.idea.pascal.lang.stub.PasIdentStubElementType"}
NamedIdent                  ::= identifier

TypeSection                 ::= TYPE typeDeclarations [";"] {pin=1 name="type section" recoverWhile=rec_decl_section}
private typeDeclarations    ::= TypeDeclaration+ {recoverWhile=rec_block_local_end}
TypeDeclaration             ::= customAttributes* GenericTypeIdent "=" type {pin=2 recoverWhile=rec_name}
private type                ::= typeForwardDecl | typeDecl
private typeDecl            ::= TypeDecl hintingDirective* ";" {pin=1}
private typeForwardDecl     ::= classForwardDecl ";"

GenericTypeIdent            ::= [GENERIC] NamedIdentDecl [genericDefinition] {recoverWhile=rec_typeId}

private genericDefinition      ::= "<" typeParamList ">" {pin=1}
private typeParamList          ::= ConstrainedTypeParam typeParamListRest*
private typeParamListRest      ::= ";" ConstrainedTypeParam //{pin=1 recoverWhile=rec_generic_def}
ConstrainedTypeParam           ::= (typeParamIdentList [ ":" genericConstraintList])
private typeParamIdentList     ::= NamedIdent identsRest*
private identsRest             ::= "," NamedIdent
private genericConstraintList  ::= GenericConstraint genericConstraintsRest*
private genericConstraintsRest ::= "," GenericConstraint
GenericConstraint              ::= TypeID | RECORD | CLASS | CONSTRUCTOR | INTERFACE | OBJECT //{recoverWhile=rec_test}
private rec_test ::= !(";" | "=" | ">" | ",") & rec_section

GenericPostfix      ::=	"<" TypeDecl typeDeclsRest* ">"             // TODO use TypeId + procedure types instead?
private typeDeclsRest       ::= "," TypeDecl {pin=1}
TypeID                      ::=	SPECIALIZE? FullyQualifiedIdent [GenericPostfix]

TypeDecl	                ::=	complexType | PointerType | ProcedureType | [TYPE] StringType | simpleType | [TYPE] TypeID

private classForwardDecl    ::= (CLASS | INTERFACE | OBJC_CLASS | OBJC_PROTOCOL) [EXTERNAL [externalSpecifier]] //{name="forward class declaration" pin=1 recoverWhile=rec_semi_section}

ClassField                  ::= field
private classFieldSemi      ::= ClassField ";" {pin=1 recoverWhile=rec_struct_field}
ClassTypeDecl               ::= [PACKED] classDecl
                            {name="class declaration"
                             extends="com.siberika.idea.pascal.lang.psi.impl.PascalClassDeclImpl"
                             implements="com.siberika.idea.pascal.lang.psi.PascalClassDecl"
                             stubClass="com.siberika.idea.pascal.lang.stub.struct.PasClassDeclStub"
                             elementTypeClass="com.siberika.idea.pascal.lang.stub.struct.PasClassDeclStubElementType"}

private classDecl           ::= classHead (classFull | classShort) {pin=1}
private classHead           ::= (CLASS | objc_decl) [ClassState]
private classFull           ::= [classParentWithRecovery] structItem* END
private classShort          ::= classParentWithRecovery //{pin=1 recoverWhile=rec_struct_outer}
private objc_decl           ::= OBJC_CLASS | OBJC_CATEGORY [EXTERNAL [externalSpecifier]]

ClassHelperDecl             ::= CLASS HELPER classHelperBody END {pin=2
                                                                  name="class helper declaration"
                                                                  extends="com.siberika.idea.pascal.lang.psi.impl.PascalClassHelperDeclImpl"
                                                                  implements="com.siberika.idea.pascal.lang.psi.PascalHelperDecl"
                                                                  stubClass="com.siberika.idea.pascal.lang.stub.struct.PasHelperDeclStub"
                                                                  elementTypeClass="com.siberika.idea.pascal.lang.stub.struct.PasClassHelperDeclStubElementType"}

private classHelperBody     ::= [classParentWithRecovery] FOR TypeID structItem* {pin=2 recoverWhile=rec_struct_outer}

InterfaceTypeDecl           ::= interfaceKey interfaceBody END
                              | interfaceKey [classParentWithRecovery] {pin(".*")=interfaceKey name="interface declaration"
                                                            extends="com.siberika.idea.pascal.lang.psi.impl.PascalInterfaceDeclImpl"
                                                            implements="com.siberika.idea.pascal.lang.psi.PascalInterfaceDecl"
                                                            stubClass="com.siberika.idea.pascal.lang.stub.struct.PasInterfaceDeclStub"
                                                            elementTypeClass="com.siberika.idea.pascal.lang.stub.struct.PasInterfaceDeclStubElementType"}

private interfaceBody       ::= [classParentWithRecovery] [interfaceGuid] structItem* {recoverWhile=rec_struct_outer}
ObjectDecl                  ::= [PACKED] objectTypeDecl {name="object declaration"
                                                         extends="com.siberika.idea.pascal.lang.psi.impl.PascalObjectDeclImpl"
                                                         implements="com.siberika.idea.pascal.lang.psi.PascalObjectDecl"
                                                         stubClass="com.siberika.idea.pascal.lang.stub.struct.PasObjectDeclStub"
                                                         elementTypeClass="com.siberika.idea.pascal.lang.stub.struct.PasObjectDeclStubElementType"}
private objectTypeDecl      ::= OBJECT objectBody END {pin=1}
private objectBody          ::= [classParentWithRecovery] structItem* {recoverWhile=rec_struct_outer}

RecordDecl                  ::= [PACKED | "bitpacked"] RECORD varRecDecl END  {pin=2 name="record declaration"
                                                                extends="com.siberika.idea.pascal.lang.psi.impl.PascalRecordDeclImpl"
                                                                implements="com.siberika.idea.pascal.lang.psi.PascalRecordDecl"
                                                                stubClass="com.siberika.idea.pascal.lang.stub.struct.PasRecordDeclStub"
                                                                elementTypeClass="com.siberika.idea.pascal.lang.stub.struct.PasRecordDeclStubElementType"}

private varRecDecl          ::= [classParentWORec] structItem* [ClassField] [recordVariantSection] {recoverWhile=rec_struct_field}
private varRecDeclInner     ::= (ClassField ";")* [ClassField] [recordVariantSection] {recoverWhile=rec_struct_field}
private field               ::= customAttributes* identListDecl ":" TypeDecl hintingDirective* {pin=2 recoverWhile=rec_struct_field}
private recordVariantSection ::= CASE [NamedIdentDecl ":"] TypeDecl OF recordVariants {pin=1}
private recordVariants      ::= (RecordVariant ";")* [RecordVariant]
RecordVariant               ::= ConstExpressionOrd ("," ConstExpressionOrd)* ":" "(" varRecDeclInner ")" {pin=4}  // rethink expression, separate simpler expressions?

RecordHelperDecl            ::= RECORD HELPER classHelperBody END {pin=2
                                                                   name="record helper declaration"
                                                                   extends="com.siberika.idea.pascal.lang.psi.impl.PascalRecordHelperDeclImpl"
                                                                   implements="com.siberika.idea.pascal.lang.psi.PascalHelperDecl"
                                                                   stubClass="com.siberika.idea.pascal.lang.stub.struct.PasHelperDeclStub"
                                                                   elementTypeClass="com.siberika.idea.pascal.lang.stub.struct.PasRecordHelperDeclStubElementType"}

ClassState                  ::= SEALED | ABSTRACT

private classParentWithRecovery ::= ClassParent {recoverWhile=rec_classparent}
private classParentWORec        ::= ClassParent
ClassParent                     ::= "(" TypeID? classParentRest ")" {pin = 1}
private classParentRest         ::= ("," TypeID)* //{pin=1 recoverWhile=rec_classparent_rest}

private interfaceGuid       ::= "[" quotedString "]"
private interfaceKey        ::= INTERFACE | DISPINTERFACE | (OBJC_PROTOCOL [EXTERNAL [externalSpecifier]])

ClassTypeTypeDecl           ::= CLASS OF TypeID {pin(".*")="class of" name="metaclass declaration"}

Visibility                  ::= [STRICT] PRIVATE | [STRICT] PROTECTED | PUBLIC | PUBLISHED | AUTOMATED

ClassProperty ::= customAttributes* [CLASS] PROPERTY NamedIdentDecl [ClassPropertyArray] [":" TypeID] [ClassPropertyIndex] ClassPropertySpecifier* ";" [DEFAULT] hintingDirective* [";"] {pin=3 recoverWhile=rec_routine_decl}
ClassPropertyArray ::= "[" formalParameterList "]" {pin=1}
ClassPropertyIndex ::= INDEX ConstExpressionOrd {pin=1}
ClassPropertySpecifier ::= classPropertyReadWrite | classPropertyDispInterface | "stored" Expression
                         | DEFAULT Expression | "nodefault" | IMPLEMENTS TypeID {recoverWhile=rec_propspec}
private classPropertyReadWrite ::= READ RefNamedIdent | WRITE RefNamedIdent | "add" RefNamedIdent | "remove" RefNamedIdent
RefNamedIdent       ::= identifier
private classPropertyDispInterface ::= "readonly" | "writeonly" | dispIDDirective

ArrayType               ::= [PACKED | "bitpacked"] ARRAY [arrayIndexes] OF arraySubType {pin=2}
private arrayIndexes    ::= "[" [ArrayIndex] arrayIndexRest* "]" {pin=1}
ArrayIndex              ::= SubRangeType | TypeID     //TODO: TypeID only?
private arrayIndexRest  ::= "," [ArrayIndex] {pin=1}
private arraySubType    ::= CONST | TypeDecl

SetType             ::= [PACKED] SET OF TypeDecl {pin=2}
FileType            ::= FILE [OF TypeDecl] {pin=1}
PointerType         ::= "^" TypeDecl {pin=1}

StringType                  ::= "string" ["[" Expression "]"] | "AnsiString" [codePageNumber]
private codePageNumber      ::= "(" ConstExpressionOrd ")" {pin=1}

ProcedureType               ::= procedureReference | simpleProcedureType {implements="com.siberika.idea.pascal.lang.psi.PascalRoutineEntity" extends="com.siberika.idea.pascal.lang.psi.impl.PascalProcedureTypeImpl"}
private simpleProcedureType ::= procedureTypeHeading {recoverWhile=rec_semi_section}
ClosureExpr                 ::= ClosureRoutine
ClosureRoutine              ::= (funcHeading | procHeading) BlockLocal

private procedureReference  ::= REFERENCE TO procedureTypeHeading
private procedureTypeHeading ::= (funcHeading | procHeading) [OF OBJECT]
private funcHeading         ::= FUNCTION [FormalParameterSection] ":" customAttributes* TypeDecl procTypeDirectives {pin=1}
private procHeading         ::= PROCEDURE [FormalParameterSection] procTypeDirectives {pin=1}
private procTypeDirectives  ::= (";" callConvention)* ([";"] callConvention)*

private simpleType          ::= EnumType | SubRangeType
SubRangeType        ::= RangeBound RANGE RangeBound
RangeBound          ::= ConstExpressionOrd
EnumType            ::= "(" enumEl enumRest* ")" {pin=1}
private enumRest    ::= "," enumEl {pin=1}
private enumEl      ::= NamedIdentDecl [(EQ | ASSIGN) Expression] {}

    private rec__stmt_start          ::= REPEAT | WHILE | FOR | CASE | WITH | RAISE | IF | TRY | BEGIN | BREAK | CONTINUE | EXIT | GOTO | INHERITED
                                  | NUMBER_INT | NUMBER_HEX | NUMBER_REAL | NUMBER_OCT | NUMBER_BIN | identifier | '^' | END "." | '[' | '('

CompoundStatement           ::= BEGIN statementBlock END {pin=1}
private statementBlock      ::= [statementList] {recoverWhile=rec_block_local_end}
private statementList       ::= [Statement] statements*
private statements          ::= ";" [Statement]
Statement                   ::= [LabelId ":" ] statementPart {recoverWhile=rec_statement}
private statementPart       ::= RepeatStatement | WhileStatement | ForStatement
                              | CaseStatement | WithStatement | RaiseStatement | AssemblerStatement
                              | IfStatement | TryStatement | simpleStatement | CompoundStatement | stmtEmpty

private simpleStatement     ::= flowStatement | stmtSimpleOrAssign | Expression | InlineConstDeclaration
private stmtSimpleOrAssign  ::= assignLeftPart [AssignPart]
private assignLeftPart      ::= InlineVarDeclaration | Expression
InlineVarDeclaration        ::= VAR customAttributes* identList [":" TypeDecl] {pin=1 methods=[getNamedIdentDeclList]}
InlineConstDeclaration      ::= CONST customAttributes* NamedIdent [":" TypeDecl] "=" ConstExpression {pin=1}
AssignOp                    ::= ":=" | PLUS_ASSIGN | MINUS_ASSIGN | MULT_ASSIGN | DIV_ASSIGN
AssignPart                  ::= AssignOp (NewStatement | Expression) {pin=1 recoverWhile=rec_statement}
NewStatement                ::= NEW "(" [ Expression ] ("," [ Expression ])* [ "," ConstExpression ] ")"// {pin=1 }
stmtEmpty                   ::= //empty

RepeatStatement             ::= REPEAT [statementList] UNTIL Expression {pin=1}
WhileStatement              ::= WHILE whileExpression doStatement {pin=1}
private whileExpression     ::= Expression {recoverWhile=rec_statement_mid}
ForStatement                ::= FOR forCycleIdent forCycleCondition doStatement {pin=1}
private forCycleIdent       ::= ForInlineDeclaration | FullyQualifiedIdent
ForInlineDeclaration        ::= VAR NamedIdent [":" TypeDecl] {pin=1 methods=[getCustomAttributeDeclList getNamedIdentDeclList]}
private forCycleCondition   ::= (forCycle | IN) Expression {recoverWhile=rec_statement_mid}
private forCycle            ::= ":=" FromExpression (TO | DOWNTO) {pin=1}
FromExpression              ::= Expression {recoverWhile=rec_statement_mid}

private doStatement         ::= doKey Statement {pin=1}
private doKey               ::= DO {recoverWhile=rec_doKey}

IfStatement                 ::= IF ctrlStmtExpression ifThenStatement [ELSE IfElseStatement] {pin=1}
private ifThenStatement     ::= THEN IfThenStatement {pin=1}
private ctrlStmtExpression  ::= Expression {recoverWhile=rec_statement_mid}
IfThenStatement             ::= Statement
IfElseStatement             ::= Statement

CaseStatement       ::= caseBody [CaseElse] END
private caseBody    ::= CASE ctrlStmtExpression OF CaseItem* {pin=1 recoverWhile=rec_case}
CaseItem	        ::=	caseLabel Statement [";"] {pin=1 recoverWhile=rec_caseItem}
CaseElse            ::= ELSE statementList {pin=1}

private caseLabel           ::= caseLabelPart ("," caseLabelPart)* ":" {pin=1}
private caseLabelPart	    ::=	ConstExpressionOrd [RANGE ConstExpressionOrd]

TryStatement                ::= TRY statementList (tryExcept | tryFinally) END {pin=1}
private tryFinally          ::= FINALLY statementList
private tryExcept           ::= exceptKey handlerList {pin=1 recoverWhile=rec_statement_mid}
private exceptKey           ::= EXCEPT {recoverWhile=rec_doKey}
private handlerList         ::= (Handler+ [ELSE statementList]) | statementList
Handler                     ::= handlerStart doStatement ";" {pin=1}
private handlerStart        ::= ON [NamedIdent ":"] TypeID {pin=1 recoverWhile=rec_statement_mid}

WithStatement               ::= WITH withArgument doStatement {pin=1}
private withArgument        ::= Expression designatorsRest* {recoverWhile=rec_statement_mid}
private designatorsRest     ::= "," Expression {}

RaiseStatement              ::= RAISE [Expression] ["at" Expression] {pin=1}

private flowStatement       ::= ExitStatement | BreakStatement | ContinueStatement | GotoStatement
ExitStatement               ::= EXIT [ "(" [Expression] ")" ]
BreakStatement              ::= BREAK
ContinueStatement           ::= CONTINUE
GotoStatement               ::= GOTO LabelId

LabelId                     ::= label

ClassQualifiedIdent         ::= (SubIdent [GenericPostfix] ".")+ SubIdent
FullyQualifiedIdent	        ::=	namespacePart? SubIdent
NamespaceIdent	            ::=	namespacePart? SubIdent {name="Identifier"}
SubIdent                    ::= identifier
private namespacePart       ::= namespaceItem+
private namespaceItem       ::= SubIdent "."// {pin=2 }

private hintingDirective    ::= (DEPRECATED [StringFactor]) | EXPERIMENTAL | PLATFORM | LIBRARY // {}
//recover_hintingDir          ::= !(';' | ')' | END | global_decl)

private identifier          ::= EscapedIdent | KeywordIdent | NAME
KeywordIdent                ::= OUT | SELF | NEW
                              | EXIT | BREAK | CONTINUE
                              | VIRTUAL | DYNAMIC | ABSTRACT | OVERLOAD | OVERRIDE | REINTRODUCE | MESSAGE | STATIC | SEALED | FINAL | ASSEMBLER
                              | CDECL | PASCAL | REGISTER | SAFECALL | STDCALL | EXPORT | OPERATOR
                              | AUTOMATED | DISPID | EXTERNAL | FORWARD | HELPER | IMPLEMENTS
                              | DEFAULT | INDEX | READ | WRITE | DEPRECATED | EXPERIMENTAL | PLATFORM | REFERENCE
                              | PACKAGE | CONTAINS | REQUIRES
private unescapedIdent      ::= reservedWord | KeywordIdent | NAME
EscapedIdent                ::= PROGRAM_ | UNIT_ | LIBRARY_ | INTERFACE_ | IMPLEMENTATION_ | INITIALIZATION_ | FINALIZATION_
                              | EXPORTS_ | USES_ | VAR_ | CONST_ | TYPE_ | THREADVAR_ | RESOURCESTRING_ | CONSTREF_ | ABSOLUTE_
                              | PROCEDURE_ | FUNCTION_ | OPERATOR_ | CONSTRUCTOR_ | DESTRUCTOR_ | STRICT_ | PRIVATE_ | PROTECTED_ | PUBLIC_ | PUBLISHED_
                              | ARRAY_ | RECORD_ | SET_ | FILE_ | OBJECT_ | CLASS_ | OF_ | PROPERTY_ | LABEL_
                              | TRY_ | RAISE_ | EXCEPT_ | FINALLY_ | ON_ | GOTO_
                              | FOR_ | TO_ | DOWNTO_ | REPEAT_ | UNTIL_ | WHILE_ | DO_ | WITH_ | BEGIN_ | END_ | IF_ | THEN_ | ELSE_ | CASE_
                              | NIL_ | FALSE_ | TRUE_ | ASM_ | INHERITED_
                              | AND_ | OR_ | XOR_ | NOT_ | SHL_ | SHR_ | DIV_ | MOD_ | IN_ | AS_ | IS_
                              | INLINE_

                              | OUT_ | SELF_ | NEW_
                              | EXIT_ | BREAK_ | CONTINUE_
                              | VIRTUAL_ | DYNAMIC_ | ABSTRACT_ | OVERLOAD_ | OVERRIDE_ | REINTRODUCE_ | MESSAGE_ | STATIC_ | SEALED_ | FINAL_ | ASSEMBLER_
                              | CDECL_ | PASCAL_ | REGISTER_ | SAFECALL_ | STDCALL_ | EXPORT_
                              | AUTOMATED_ | DISPID_ | EXTERNAL_ | FORWARD_ | HELPER_ | IMPLEMENTS_
                              | DEFAULT_ | INDEX_ | READ_ | WRITE_ | DEPRECATED_ | EXPERIMENTAL_ | PLATFORM_ | REFERENCE_
                              | PACKAGE_ | CONTAINS_ | REQUIRES_

                              | NAME_
private reservedWord	    ::= PROGRAM | UNIT | LIBRARY | INTERFACE | IMPLEMENTATION | INITIALIZATION | FINALIZATION
                              | EXPORTS | USES | VAR | CONST | TYPE | THREADVAR | RESOURCESTRING | CONSTREF | ABSOLUTE
                              | PROCEDURE | FUNCTION | OPERATOR | CONSTRUCTOR | DESTRUCTOR | STRICT | PRIVATE | PROTECTED | PUBLIC | PUBLISHED
                              | ARRAY | RECORD | SET | FILE | OBJECT | CLASS | OF | PROPERTY | LABEL
                              | TRY | RAISE | EXCEPT | FINALLY | ON | GOTO
                              | FOR | TO | DOWNTO | REPEAT | UNTIL | WHILE | DO | WITH | BEGIN | END | IF | THEN | ELSE | CASE
                              | NIL | FALSE | TRUE | ASM | INHERITED
                              | AND | OR | XOR | NOT | SHL | SHR | DIV | MOD | IN | AS | IS
                              | INLINE
                                //===***
private identList	        ::=	identListItem identListRest*
private identListRest       ::= "," identListItem {pin=1}
private identListItem       ::= NamedIdent

ConstExpression	            ::=	constExpr {recoverWhile=rec_expr_colon name="constant expression"}
private constExpr           ::= RecordConstExpr | ArrayConstExpr | Expression
ArrayConstExpr              ::= "(" constExpr ("," constExpr)+ ")"
ConstExpressionOrd          ::=	expressionOrd {name="integer constant expression" extends=ConstExpression}
RecordConstExpr             ::= "(" recordConstInner ")"
private recordConstInner    ::= recordValue recordValueRest* [";"] {recoverWhile=rec_record_colon}
private recordValueRest     ::= ";" recordValue
private recordValue         ::= identifier ":" constExpr

private rec_record_colon    ::= !(")" | END)
private rec_expr_colon      ::= !(")" | ";" | INDEX | "name" | "delayed" | "dependency" | "deprecated" | "platform") & rec_section

/*private Designator                  ::= //[ "inherited" ] , [ QualifiedIdent | TypeID ] , { DesignatorItem } ===***
                                INHERITED [TypeID] exprParentheses? | EntityID DesignatorItemEx* | DesignatorItemEx+
private DesignatorItem      ::= "^" | "." FieldId | "[" ExpressionsList "]"
private DesignatorItemEx    ::= DesignatorItem | exprParentheses
private exprParentheses     ::= "(" exprInParentheses ")" {pin=1}
private exprInParentheses   ::= [ExpressionColon ExpressionColons*] {recoverWhile=rec_expr_colon}
private ExpressionColon     ::= Expression [ColonConstruct] {}
private ExpressionColons    ::= "," ExpressionColon
private ColonConstruct      ::= ":" Expression [ ":" Expression ]

private primary             ::= AT primary | AT AT primary | NOT primary | PLUS primary | MINUS primary
                              | NUMBER_INT | NUMBER_REAL | NUMBER_HEX | NUMBER_BIN | TRUE | FALSE | NIL
                              | StringFactor | SetSection | Designator

private primaryOrd          ::= NOT primaryOrd | PLUS primaryOrd | MINUS primaryOrd | NUMBER_INT | NUMBER_HEX | TRUE | FALSE | NIL
                              | "(" ExpressionOrd ")" | StringFactor | Designator


Expression ::= ClosureExpression | expr_rel
private expr_rel            ::= expr_sum relOpRest*
private relOpRest           ::= relOp expr_sum {pin=1 }
private expr_sum            ::= expr_product addOpRest*
private addOpRest           ::= addOp expr_product {pin=1 }
private expr_product        ::= primary mulOpRest*
private mulOpRest           ::= mulOp primary {pin=1 }

ExpressionOrd ::= expr_relOrd
private expr_relOrd ::= expr_sumOrd (relOp expr_sumOrd)*
private expr_sumOrd ::= expr_productOrd (addOp expr_productOrd)*
private expr_productOrd ::= primaryOrd (mulOp primaryOrd)* */
// **********************************************************************
relOp                       ::= (GT EQ) | LTEQ | LT | GT | NE | EQ | IN | IS
addOp                       ::=	PLUS | MINUS | OR | XOR
mulOp                       ::= "*" | "/" | IDIV | MOD | AND | SHL | SHR | (">"">") | AS
unaryOp                     ::= "+" | "-" | "@" | NOT

private expressionOrd       ::= Expression
Expression                  ::= Expr

Expr                        ::= sumExpr | productExpr | relationalExpr | unaryExpr | referenceExpr | callGroup | primaryGroup {extends="com.siberika.idea.pascal.lang.psi.impl.PascalExpression"}
relationalExpr              ::= Expr relOp Expr
sumExpr                     ::= Expr addOp Expr
productExpr                 ::= Expr mulOp Expr
unaryExpr                   ::= unaryOp Expr
dereferenceExpr             ::= Expr '^'
referenceExpr               ::= Expr '.' FullyQualifiedIdent [GenericPostfix]
simpleRefExpr               ::= ((InheritedCall | SPECIALIZE)? FullyQualifiedIdent [GenericPostfix]) | InheritedCall {elementType=referenceExpr}  // let qualified and simple references have the same type
callExpr                    ::= Expr ArgumentList
indexExpr                   ::= Expr indexList
ArgumentList                ::= '(' [ !')' Expr [ColonConstruct]  (',' Expr [ColonConstruct]) * ] ')' {pin(".*")=1}
private parenConstruct      ::= '(' [ !')' Expr (',' Expr) * ] ')' {pin(".*")=1}
ColonConstruct              ::= ':' Expr [':' Expr]
indexList                   ::= '[' Expr (',' Expr) * ']' {pin=1}
parenExpr                   ::= parenConstruct
setExpr                     ::= '[' [ !']' Expr setTail * ] ']' {pin(".*")=1}
private setTail             ::= ("," | ".." | ) Expr //{}
private primaryGroup        ::= simpleRefExpr | literalExpr | parenExpr | setExpr | ClosureExpr
private callGroup           ::= callExpr | indexExpr | dereferenceExpr
literalExpr                 ::= NUMBER_REAL | NUMBER_INT | NUMBER_HEX | NUMBER_OCT | NUMBER_BIN | TRUE | FALSE | NIL | StringFactor
// **********************************************************************
FormalParameterSection      ::= formalParameterSect
private formalParameterSect ::= "(" [ formalParameterList ] ")" {pin=1 recoverWhile=rec_formal_param_sec}
private formalParameterList ::= FormalParameter (";" FormalParameter)*
FormalParameter             ::= customAttributes* [ ParamType ] identList [ ":" TypeDecl ] [ "=" ConstExpression ] {pin=3
                                                        recoverWhile=rec_formal_param
                                                        mixin="com.siberika.idea.pascal.lang.psi.impl.PasFormalParameterMixin"}
ParamType                   ::= CONST | VAR | OUT | CONSTREF//ParmType

AttributeParamList	        ::= Expression (COMMA Expression)*

InheritedCall               ::= INHERITED {implements="com.intellij.psi.ContributedReferenceHost" extends="com.siberika.idea.pascal.lang.psi.impl.PascalInheritedCall"}

private customAttributes	::=	LBRACK CustomAttributeList RBRACK | assemblyAttribute {pin=1}
private CustomAttributeList ::= CustomAttributeDecl (COMMA CustomAttributeDecl)* {recoverWhile=rec_attr2}
private rec_attr2 ::= !(RBRACK)
CustomAttributeDecl         ::= FullyQualifiedIdent [LPAREN AttributeParamList RPAREN] {recoverWhile=rec_attr}
private rec_attr            ::= !(COMMA | RBRACK | identifier)
StringFactor                ::= controlString (quotedString controlString)* [quotedString]
                              | quotedString (controlString quotedString)* [controlString] {extends="com.siberika.idea.pascal.lang.psi.impl.PascalStringImpl"}
private quotedString        ::=	STRING_LITERAL
private controlString       ::=	controlchar+
private controlchar         ::= CHARNUM NUMBER_INT | CHARNUM NUMBER_HEX // ***===
